// Logic for making sure the same response is not reported multiple times.
//
// Responses are generated by several APIs and rather than filtering them in the UI
// or the backend we filter them here to make sure the same response is never reported
// multiple times.

import type { ChatResponse } from '~/lib/persistence/response';
import type { ChatResponseCallback } from './SendChatMessage';
import { createScopedLogger } from '~/utils/logger';
import { APP_SUMMARY_CATEGORY } from '~/lib/persistence/messageAppSummary';
import { assert } from '~/utils/nut';

const logger = createScopedLogger('ChatResponses');

const gResponsesByTime = new Map<string, ChatResponse[]>();
let gLastResponseTime = new Date(0).toISOString();

function responseMatches(a: ChatResponse, b: ChatResponse) {
  // Special case AppSummary messages. These are generated from different places in the
  // backend and might not be exactly identical after JSON.stringify. Compare the summaries
  // themselves.
  if (a.kind == 'message' && b.kind == 'message') {
    const aMessage = a.message;
    const bMessage = b.message;
    if (aMessage.category == APP_SUMMARY_CATEGORY && bMessage.category == APP_SUMMARY_CATEGORY) {
      assert(aMessage.type == 'text' && bMessage.type == 'text', 'AppSummary messages must be text');
      return aMessage.content === bMessage.content;
    }
  }

  return JSON.stringify(a) == JSON.stringify(b);
}

export function addAppResponse(response: ChatResponse) {
  let existing = gResponsesByTime.get(response.time);
  if (existing && existing.some((r) => responseMatches(r, response))) {
    logger.trace('duplicateResponse', JSON.stringify(response));
    return false;
  }

  logger.trace('onResponse', JSON.stringify(response));

  if (Date.parse(response.time) > Date.parse(gLastResponseTime)) {
    gLastResponseTime = response.time;
  }

  if (!existing) {
    existing = [];
    gResponsesByTime.set(response.time, existing);
  }
  existing.push(response);
  return true;
}

export function filterOnResponseCallback(onResponse: ChatResponseCallback): ChatResponseCallback {
  return (response: ChatResponse) => {
    if (addAppResponse(response)) {
      onResponse(response);
    }
  };
}

export function clearAppResponses() {
  gResponsesByTime.clear();
  gLastResponseTime = new Date(0).toISOString();
}

export function getLastResponseTime() {
  return gLastResponseTime;
}

export function getAllAppResponses() {
  return Array.from(gResponsesByTime.values()).flat();
}
