// Logic for making sure the same response is not reported multiple times.
//
// Responses are generated by several APIs and rather than filtering them in the UI
// or the backend we filter them here to make sure the same response is never reported
// multiple times.

import type { ChatResponse } from '~/lib/persistence/response';
import type { ChatResponseCallback } from './SendChatMessage';
import { createScopedLogger } from '~/utils/logger';
import { assert } from '~/utils/nut';

const logger = createScopedLogger('ChatResponses');

const gResponsesByTime = new Map<string, ChatResponse[]>();
let gLastResponseTime = new Date(0).toISOString();

function responseMatches(a: ChatResponse, b: ChatResponse) {
  if (a.kind != b.kind) {
    return false;
  }

  switch (a.kind) {
    case 'message': {
      assert(b.kind == 'message', 'Expected message');
      const aMessage = a.message;
      const bMessage = b.message;

      // Compare based on id and content. When a message is split into multiple responses
      // they could share the same timestamp. (They could share the same content
      // as well but we don't handle this case.)
      if (aMessage.id === bMessage.id) {
        if (aMessage.type == 'text' && bMessage.type == 'text' && aMessage.content != bMessage.content) {
          return false;
        }
        return true;
      }
      return false;
    }
    case 'app-event': {
      assert(b.kind == 'app-event', 'Expected app-event');
      return JSON.stringify(a.event) == JSON.stringify(b.event);
    }
    default:
      return JSON.stringify(a) == JSON.stringify(b);
  }
}

export function addAppResponse(response: ChatResponse) {
  let existing = gResponsesByTime.get(response.time);
  if (existing && existing.some((r) => responseMatches(r, response))) {
    logger.trace('duplicateResponse', JSON.stringify(response));
    return false;
  }

  logger.trace('onResponse', JSON.stringify(response));

  if (Date.parse(response.time) > Date.parse(gLastResponseTime)) {
    gLastResponseTime = response.time;
  }

  if (!existing) {
    existing = [];
    gResponsesByTime.set(response.time, existing);
  }
  existing.push(response);
  return true;
}

export function filterOnResponseCallback(onResponse: ChatResponseCallback): ChatResponseCallback {
  return (response: ChatResponse) => {
    if (addAppResponse(response)) {
      onResponse(response);
    }
  };
}

export function clearAppResponses() {
  gResponsesByTime.clear();
  gLastResponseTime = new Date(0).toISOString();
}

export function getLastResponseTime() {
  return gLastResponseTime;
}

export function getAllAppResponses() {
  return Array.from(gResponsesByTime.values()).flat();
}

if (typeof window !== 'undefined') {
  (window as any).__NUT_DUMP_RESPONSES__ = () => {
    console.log(JSON.stringify(getAllAppResponses()));
  };
}
